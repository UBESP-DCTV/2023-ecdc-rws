---
title: '[Day One]{style="color:darkblue"}:<br>[Introduction to R]{style="color:darkorange;"}'
subtitle: "90 min approx"
format:
  revealjs:
    width:  1648 #(3/2)
    height: 1080
    logo: img/UBEP.png
    footer: "UBEP's R training for supervisors"
    slide-number: true
    history: false
    preview-links: auto
    code-link: true
    multiplex: true
    chalkboard: 
      src: src/chalkboard-presentation.json
bibliography: references.bib
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(
  echo = TRUE
)
library(tidyverse)
library(countdown)
```

# Overview {style="color:darkblue;"}

## 

::: columns
::: {.column width="50%"}
### Questions

- What can I actually do with R?
- How can I start working in R from scratch?
- What kind of objects have R?
- How can I manage them?
- How can I control the flow of code execution?
- How can I define custom functions?
- What are and how can I use extension packages in R?

:::

::: {.column width="50%"}
### Lesson Objectives

#### To be able to do/use

- Basic operations in R (math, logic, assign, subsetting).
- Define `for` loops and `if` conditional executions
- Create functions
- install, and attach packages, and getting help

:::
:::

# R basics

## Language

::: columns
::: {.column width="35%"}
|          |     |
|----------|-----|
| Comments | `#` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
# R will ignore this!!
1 + 1 # +1 also this!!
```
:::
:::

::: columns
::: {.column width="35%"}
|            |      |
|------------|------|
| Assignment | `<-` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
two <- 1 + 1
two
```
:::
:::

::: callout-important
Var names can contain letters, numbers, underscores and periods but no spaces. They must start with a letter (or a single dot, for hidden variables).
:::

::: columns
::: {.column width="35%"}
|                |     |
|----------------|-----|
| Create vectors | `c` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
three_two_one <- c(3, two, 1)
three_two_one
```
:::
:::

::: columns
::: {.column width="35%"}
|        |              |
|--------|--------------|
| Subset | `?[` or `[[` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
#| results: hold
three_two_one[c(2, 3)] 
three_two_one[[1]] # R counts from 1
```
:::
:::

::: columns
::: {.column width="35%"}
|              |      |
|--------------|------|
| List objects | `ls` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
ls()
```
:::
:::

::: columns
::: {.column width="35%"}
|                |      |
|----------------|------|
| Remove objects | `rm` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
rm(three_two_one)
ls()
```
:::
:::

::: columns
::: {.column width="35%"}
|           |                  |
|-----------|------------------|
| functions | `fun(arg = val)` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
# Use `=` to assign vals to args
mean(x = c(1, 2, 3))
```
:::
:::

::: columns
::: {.column width="35%"}
|                 |        |
|-----------------|--------|
| R's null object | `NULL` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
#| results: hold
NULL
```
:::
:::

::: columns
::: {.column width="35%"}
|               |           |
|---------------|-----------|
| Help function | `?fun`    |
| Help operator | `?"<op>"` |
:::

::: {.column width="65%"}
::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| echo: true
#| output-location: column
?sum
?"+"
```
:::

::: {.column width="45%"}
![](img/mean-help-crop.png)
:::
:::
:::
:::

## Your turn

::: callout-caution
## Your turn

Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>) and:

1.  Put `x`s next to the correct variable names.
:::

```{r}
#| echo: false
countdown(
  minutes = 1,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```

## Math

::: columns
::: {.column width="35%"}
|             |             |
|-------------|-------------|
| Brackets    | `(`, `)`    |
| Add         | `+`         |
| Subtract    | `-`         |
| Multiply    | `*`         |
| Divide      | `/`         |
| Exponent    | `^` or `**` |
| Square root | `sqrt`      |
:::

::: {.column width="65%"}
<br><br><br>

```{r}
#| output-location: column
# Standrard order of precedence
5 + sqrt(4) / 2 * 3^(2 - 1)
```
:::
:::

::: columns
::: {.column width="35%"}
|           |                 |
|-----------|-----------------|
| Magnitude | `<num>E<exp10>` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
1E2
```
:::
:::

::: columns
::: {.column width="35%"}
|             |       |
|-------------|-------|
| Exponential | `exp` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
# Euler number
exp(1)
```
:::
:::

::: columns
::: {.column width="35%"}
|           |                        |
|-----------|------------------------|
| Logarithm | `log`, `log10`, `log2` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
# You can compose functions
log(exp(1))
```
:::
:::

::: columns
::: {.column width="35%"}
|     |      |
|-----|------|
| Pi  | `pi` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
pi
```
:::
:::

::: columns
::: {.column width="35%"}
|      |       |
|------|-------|
| Sine | `sin` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
sin(pi/2)
```
:::
:::

::: columns
::: {.column width="35%"}
|        |       |
|--------|-------|
| Cosine | `cos` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
cos(pi)
```
:::
:::

## Logic and tests

::: columns
::: {.column width="35%"}
|       |         |
|-------|---------|
| True  | `TRUE`  |
| False | `FALSE` |
| And   | `&`     |
| Or    | `|`     |
| Not   | `!`     |
:::

::: {.column width="65%"}
<br>

```{r}
#| output-location: column
# Standard order of precedence
TRUE & FALSE
```

```{r}
#| output-location: column
# Standard order of precedence
!TRUE | TRUE
```

```{r}
#| output-location: column
!(TRUE | TRUE)
```
:::
:::

::: columns
::: {.column width="35%"}
|            |                      |
|------------|----------------------|
| Comparison | `<`, `<=`, `>`, `>=` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
sum(1:3) > 4
```
:::
:::

::: columns
::: {.column width="35%"}
|                |      |
|----------------|------|
| "Exact!" Equal | `==` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
(1 + 2) == 3
```
:::
:::

::: columns
::: {.column width="35%"}
|                    |             |
|--------------------|-------------|
| Test equal numbers | `all.equal` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
3/5 == 0.6
```

```{r}
#| output-location: column
3*(1/5) == 0.6 # finite machine
```

```{r}
#| output-location: column
all.equal(3*(1/5), 0.6)
```
:::
:::

::: columns
::: {.column width="35%"}
|           |      |
|-----------|------|
| Different | `!=` |
:::

::: {.column width="65%"}
```{r}
#| output-location: column
1 != 2
```
:::
:::

## Your turn

::: callout-caution
## Your turn

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

1.  Before to evaluate it, in the pad, under the section `1.1. Ex2`, write (in a new line) what is your expected result from the following computation:

``` r
(4:2 - 1) >= 3
```

2.  Then, open the script `01-math_and_logic.R` and follow the instruction step by step.

::: {.fragment .fade-out fragment-index="1"}
```{r}
#| echo: false
countdown(
  minutes = 1,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```
:::

::: {.fragment .fade-in fragment-index="1"}
::: callout-important
-   `a:b` create a sequence of from `a` to `b`
-   `a` and `b` can be zero or negative
-   The sequence start from `a` and go through `b` in by steps of length `1`, without surpasses `b`
-   Math and logic works on vectors (i.e., sequences) input and output!
-   Prefer `?seq`, `?seq_len` and `?seq_along` instead of `?":"` when bounds are not proper number but variables and you are writing scripts (not always interactive): they have more consistent behavior and edge-situations error handling.
:::
:::

## Data structure: (atomic) vectors

Atomic vectors are homogeneous/flat objects, i.e. all the objects composing the sequence **must** be of the same type, and cannot contain other (nested) sequences.

Four main types (`?typeof`) of atomic vectors:

::: columns
::: {.column width="30%"}
|         |               |
|---------|---------------|
| Logical | `?is.logical` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(TRUE)
```

```{r}
#| output-location: column
c(is.atomic(FALSE), is.logical(FALSE))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|         |               |
|---------|---------------|
| Integer | `?is.integer` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(1:3)
```

```{r}
#| output-location: column
c(is.atomic(1:3), is.integer(1:3))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|        |              |
|--------|--------------|
| Double | `?is.double` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(1.2)
```

```{r}
#| output-location: column
c(is.atomic(1.2), is.double(1.2))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|           |                 |
|-----------|-----------------|
| Character | `?is.character` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof("Hello supervisors")
```

```{r}
#| output-location: column
c( # line brakes don't brake execution
  is.atomic("Hello supervisors"),
  is.character("Hello supervisors")
)
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
Elements can be named
:::

::: {.column width="70%"}
```{r}
#| output-location: column
c(one = 1, two = 2, three = 3)
```
:::
:::

## Your turn

::: callout-caution
## Your turn

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

1.  Before to evaluate it, in the pad, under the section `1.1. Ex3`, write (in a new line) what is your expected result (including *an error*) from the following computation:

``` r
mixed_vector <- c(
  one = TRUE, two = 2L,
  three = 3.3, four = "four"
)
mixed_vector
typeof(mixed_vector)
```

2.  Then, open the script `02-atomic-vectors.R` and follow the instruction step by step.

::: {.fragment .fade-out fragment-index="1"}
```{r}
#| echo: false
countdown(
  minutes = 1,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```
:::

::: {.fragment .fade-in fragment-index="1"}
::: columns
::: {.column width="30%"}
Coercion rule<br>from *specific* to *general*:<br><small>logical \> integer \> double \> character</small>
:::

::: {.column width="70%"}
```{r}
#| output-location: column
mixed_vector <- c(
  one = TRUE, two = 2L,
  three = 3.3, four = "four"
)
mixed_vector
```

```{r}
#| output-location: column
typeof(mixed_vector)
```
:::
:::
:::

## Data structure: (other) vectors - Factors

Other structure in R are based on atomic vectors, i.e. are of one of the base types but have more *structure* (similar structures are called `?class`)

**Factors** are discrete (i.e. based on `?integer`s) variables with labels.

::: columns
::: {.column width="25%"}
|         |              |
|---------|--------------|
| Factors | `?is.factor` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
gender <- factor(
  c("male", "female", "female"),
  levels = c("female", "male", "other")
)
gender
```

```{r}
#| output-location: column
is.factor(gender)
```

```{r}
#| output-location: column
typeof(gender)
```

```{r}
#| output-location: column
class(gender)
```

```{r}
#| output-location: column
as.character(gender)
```

```{r}
#| output-location: column
as.integer(gender)
```
:::
:::

::: columns
::: {.column width="25%"}
|        |           |
|--------|-----------|
| Levels | `?levels` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
levels(gender)
```
:::
:::

::: callout-tip
You can investigate the internal structure of any R objects using `?str`.
:::

::: columns
::: {.column width="25%"}
|           |        |
|-----------|--------|
| Structure | `?str` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
str(gender)
```
:::
:::

## Data structure: (other) vectors - Dates / Date-times

Other structure in R are based on atomic vectors, i.e. are of one of the base types but have more *structure* (similar structures are called `?class`)

**Dates** are counts (based on `?double`s) of days since 1970-01-01.[^5]

[^5]: This date is know as the Unix Epoch.

::: columns
::: {.column width="30%"}
|       |            |
|-------|------------|
| Dates | `?as.Date` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
date <- as.Date("1970-01-10")
date
```

```{r}
#| output-location: column
typeof(date)
```

```{r}
#| output-location: column
class(date)
```

```{r}
#| output-location: column
as.double(date)
```

```{r}
#| output-location: column
str(date)
```
:::
:::

**Date-Time** are counts (based on `?double`s) of seconds since 1970-01-01.

::: columns
::: {.column width="30%"}
|            |                   |
|------------|-------------------|
| Date-times | `?as.POSIXct`[^6] |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
date_time <- as.POSIXct(
  "1970-01-10 13:10",
  tz = "UTC"
)
date_time
```

```{r}
#| output-location: column
typeof(date_time)
```

```{r}
#| output-location: column
class(date_time)
```

```{r}
#| output-location: column
as.double(date_time)
```

```{r}
#| output-location: column
str(date_time)
```
:::
:::

[^6]: POSIXct: "Portable Operating System Interface - Calendar Time".

## Data structure: list (vectors)

List vectors are heterogeneous/nestable objects, i.e. objects composing the sequence **can** be of distinct types, and can contain other (nested) sequences.

::: columns
::: {.column width="15%"}
|      |         |
|------|---------|
| List | `?list` |
:::

::: {.column width="85%"}
```{r}
#| output-location: column
db_list <- list(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)
db_list
```

<br>

```{r}
#| output-location: column
str(db_list)
```
:::
:::

## Data structure: (other) lists - data frames (and tibble)

Other structure in R are based on list vectors, i.e. are heterogeneous sequence of objects.

**data frames** are ordered list of equally sized homogeneous named vectors. I.e. the are used for tabular data:

::: foo-to-separate-the-list-from-the-below-columns
-   ordered list of columns of information, with headers (`?names`)
-   in a column there is one type of information (homogeneous)
-   all columns have the same `?length`, i.e. number of rows (`?nrow`)
:::

::: columns
::: {.column width="30%"}
|             |               |
|-------------|---------------|
| Data frames | `?data.frame` |

::: callout-tip
During the course we will see, explain and use *tibbles* (from the package `{tibble}`): a modern, enhanced, better displayed, and with stricter and more consistent structure than standard data frames.
:::
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df <- data.frame(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)
db_df
```

```{r}
#| output-location: column
names(db_df)
```

```{r}
#| output-location: column
nrow(db_df)
```

```{r}
#| output-location: column
ncol(db_df)
```

```{r}
#| output-location: column
dim(db_df)
```
:::
:::

## Data structure: *vectors* as trains

::: callout-important
R works on vectors of two types only:

-   **Atomic** (homogeneous / flat)
-   **List** (heterogeneous / nested)
:::

Think of objects in R (any objects in R!) as a train (either atomic or list) made of wagons:

-   a train (i.e., a vector) is sequence of wagons (i.e., objects, homogeneous or heterogeneous, possibly other trains)
-   wagons have content (i.e., the data they contain)
-   wagons can have labels (i.e., names)

## Data structure: Subsetting data - subset

::: callout-important
You can refer to *subsetting* objects (i.e., a train) as performing two operations mainly:

-   create another objects (i.e., another train) with a subset of its elements (i.e., wagons)
-   extract the content of a (single) object (i.e., the content of a wagon)

You can select more than one object/*wagon* when subsetting, but a single one only when *extracting*!
:::

Three ways to identify elements (i.e., wagons):

::: columns
::: {.column width="30%"}
|          |     |
|----------|-----|
| Original |     |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df
```
:::
:::

::: columns
::: {.column width="30%"}
|                    |     |
|--------------------|-----|
| Subset by position | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c(2, 3)]
```
:::
:::

::: columns
::: {.column width="30%"}
|                 |     |
|-----------------|-----|
| Subset by names | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c("height", "age")]
```
:::
:::

::: columns
::: {.column width="30%"}
|                     |     |
|---------------------|-----|
| Subset by logic[^7] | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c(TRUE, FALSE, FALSE, TRUE)]
```
:::
:::

[^7]: Logical subsetting vector **must** be the same `?lenght` of the object (i.e., number of train's wagons).

## Data structure: Subsetting data - coordinates

::: callout-important
A data frame (and `tibble`s) can be see as a "matrix" (or a table).
:::

Data frames values can be subsetted using "\[rows, column\]" notation

::: columns
::: {.column width="40%"}
|          |     |
|----------|-----|
| Original |     |
:::

::: {.column width="60%"}
```{r}
#| output-location: column
db_df
```
:::
:::

::: columns
::: {.column width="40%"}
|             |                |
|-------------|----------------|
| coordinates | `[rows, cols]` |
:::

::: {.column width="60%"}
```{r}
#| output-location: column
db_df[3, 2]
```

```{r}
#| output-location: column
db_df[3, "age"]
```
:::
:::

::: columns
::: {.column width="40%"}
|                                    |                          |
|------------------------------------|--------------------------|
| ask *anything*<br>get *everything* | `[, cols]`<br>`[rows, ]` |
:::

::: {.column width="60%"}
```{r}
#| output-location: column
db_df[, "age"]
```

```{r}
#| output-location: column
db_df[3, ]
```
:::
:::

::: columns
::: {.column width="40%"}
|                    |     |
|--------------------|-----|
| multiple selection | `[` |
:::

::: {.column width="60%"}
```{r}
#| output-location: column
db_df[3, 1:2]
```

```{r}
#| output-location: column
db_df[3:2, c(2, 4)]
```
:::
:::

::: columns
::: {.column width="40%"}
::: callout-tip
Use the additional argument `drop = FALSE` to maintain the data frame structure. Using `tibble`s we will consistently get always a `tibble` when subsetting with coordinates!
:::
:::

::: {.column width="60%"}
```{r}
#| output-location: column
db_df[3, 2, drop = FALSE]
```

```{r}
#| output-location: column
db_df[3, "age", drop = FALSE]
```

```{r}
#| output-location: column
db_df[, "age", drop = FALSE]
```
:::
:::

## Data structure: Subsetting data - extract

::: callout-important
You can refer to *subsetting* objects (i.e., a train) as performing two operations mainly:

-   create another objects (i.e., another train) with a subset of its elements (i.e., wagons)
-   extract the content of a (single) object (i.e., the content of a wagon)

You can select more than one object/*wagon* when subsetting, but a single one only when *extracting*!
:::

Two ways to identify a (single!) element (i.e., a wagon):

::: foo-to-separate-the-list-from-the-below-columns
-   with its position.
-   with its name, if it has a name.
:::

::: columns
::: {.column width="30%"}
|          |     |
|----------|-----|
| Original |     |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df
```
:::
:::

::: columns
::: {.column width="30%"}
|            |      |
|------------|------|
| Extracting | `[[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[[1]]
```

```{r}
#| output-location: column
db_df[["height"]]
```
:::
:::

::: columns
::: {.column width="30%"}
|            |         |
|------------|---------|
| Extracting | `$`[^8] |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df$height
```
:::
:::

[^8]: Discouraged in non-interactive usage because of its unpredictable results due to partial matching (`?"$"` ).

## Your turn

::: callout-caution
## Your turn

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

1.  Before to evaluate it, in the pad, under the section `1.1. Ex4`, write (in a new line) what is your expected result from the following computation:

``` r
db_df <- db_df <- data.frame(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)

db_df[[4]][[3]]
db_df[3, 4, drop = FALSE]
db_df[3, 4]
db_df[[4]][3]
db_df[4][[3]]
```

2.  Then, open the script `03-subsetting.R` and follow the instruction step by step.

```{r}
#| echo: false
countdown(
  minutes = 3,
  left = "25%",
  right = "25%",
  top = "65%",
  bottom = "5%",
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```

## Your turn

::: callout-caution
## Your turn

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

::: columns
::: {.column width="35%"}
```{r}
db_df
```
:::

::: {.column width="65%"}
```{r}
#| output-location: column
db_df[[4]][[3]]
```

```{r}
#| output-location: column
db_df[3, 4, drop = FALSE]
```

```{r}
#| output-location: column
db_df[3, 4]
```

```{r}
#| output-location: column
db_df[[4]][3]
```

```{r}
#| output-location: column
#| error: true
db_df[4][[3]]
```
:::
:::

::: callout-important
-   Subset operation can be performed in sequence on the same object directly.
-   Crucial to know if you are working on a subset of an object or its content.
:::

## Control flow

::: columns
::: {.column width="45%"}
+---------------------+------------------------------------+
| If-then             | ``` r                              |
|                     | if (cond) {                        |
|                     |   # <code>                         |
|                     | }                                  |
|                     | ```                                |
+---------------------+------------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
x <- 3

print("start")
if (x > 3) {
  print("ok")
}
print("end")
```
:::
:::

<br>

::: columns
::: {.column width="45%"}
+---------------------+------------------------------------+
| If-then-else        | ``` r                              |
|                     | if (cond) {                        |
|                     |   # <code>                         |
|                     | } else {                           |
|                     |   # <code>                         |
|                     | }                                  |
|                     | ```                                |
+---------------------+------------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
print("start")
if (x > 3) {
  print("ok")
} else {
  print("ko")
}
print("end")
```
:::
:::

<br>

::: columns
::: {.column width="45%"}
::: callout-tip
You don't need to test if a logical is `TRUE` or `FALSE`, they *are* already `TRUE` or `FALSE`!
:::
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
is_to_print <- TRUE

if (is_to_print) {
  print("ok")
} else {
  print("ko")
}
```
:::
:::

::: columns
::: {.column width="45%"}
+---------------------+------------------------------------+
| For cycles          | ``` r                              |
|                     | for (<var> in <vector>) {          |
|                     |   # <code>                         |
|                     | }                                  |
|                     | ```                                |
+---------------------+------------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
print("start")
for (i in seq_len(x)) {
  print(paste("i is:", i))
}
print("start")
```
:::
:::

## Functions

::: columns
::: {.column width="45%"}
+---------------------+-------------------------------+
| Definition          | ``` r                         |
|                     | name <- function(args) {      |
|                     |   # body code of the funciton |
|                     | }                             |
|                     | ```                           |
+---------------------+-------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
sum_one <- function(x) {
  x + 1 # <1>
}
sum_one(x = 3)
```

1.  A function always returns its last evaluated objects.
:::
:::

<br>

::: columns
::: {.column width="45%"}
+---------------------+------------------------------------+
| Default             | ``` r                              |
|                     | name <- function(args = default) { |
|                     |   # body code of the funciton      |
|                     | }                                  |
|                     | ```                                |
+---------------------+------------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
sum_one <- function(x = 3) {
  x + 1
}
sum_one()
sum_one(x = 3)
```
:::
:::

<br>

::: columns
::: {.column width="45%"}
+----------------------+-------------------------------+
| Positional arg match | `?function`                   |
+----------------------+-------------------------------+
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
x_exp_y <- function(x, y) {
  x^y
}
x_exp_y(2, 3)
```
:::
:::

<br>

::: columns
::: {.column width="45%"}
::: callout-tip
To avoid confusion, don't mix positional and named argument match using non standard order: start positional, and once you name an argument name all the subsequent!
:::
:::

::: {.column width="55%"}
```{r}
#| output-location: column
#| results: hold
x_exp_y(y = 3, 2)
```
:::
:::

## Your turn

::: callout-caution
## Your turn

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

1.  Before to evaluate it, in the pad, under the section `1.1. Ex5`, write (in a new line) what is your expected result from the following computation:

``` r
<code>
```

2.  Then, open the script `04-cond-and-funs.R` and follow the instruction step by step.

::: {.fragment .fade-out fragment-index="1"}
```{r}
#| echo: false
countdown(
  minutes = 2,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```
:::

::: {.fragment .fade-in fragment-index="1"}
::: callout-important
-   `?if` returns the last computed value, if any, or `NULL` otherwise (which may happen if there is no `else`).
-   `?for` returns `NULL`
:::
:::

## Packages

A **package** is a container of functions and data sets.

A **library** is a folder in your computer that store packages. They can be of three type:

::: foo-to-separate-the-list-from-the-below-columns
1.  project (may exists, powered by `{renv}` package... we will see that)
2.  user (may exists)
3.  system (always exists)
:::

::: columns
::: {.column width="55%"}
|                  |                     |
|------------------|---------------------|
| Install packages | `?install.packages` |
:::

::: {.column width="45%"}
```{r}
#| output-location: column
#| results: hold
install.packages("tibble")
```
:::
:::

::: columns
::: {.column width="55%"}
|                 |            |
|-----------------|------------|
| Attach packages | `?library` |
:::

::: {.column width="45%"}
```{r}
#| output-location: column
#| results: hold
library("tibble")
```
:::
:::

::: columns
::: {.column width="55%"}
|          |                                |
|----------|--------------------------------|
| Help[^9] | `help(package = "<pkg_name>")` |
:::

::: {.column width="45%"}
```{r}
#| output-location: column
#| results: hold
help(package = "tibble")
```
:::
:::

[^9]: Packages help pages include the list (with link to the corresponding documentation) of all their functions and data sets.

::: callout-important
*Install* a package means store its R executable code in one of the libraries.<br>*Attach* a package means be able to use its functions and dataset within the current R session.

You need to **install** a package you want to use once only (plus updates or if you need it inside multiple libraries).<br>Anytime you (re)start an R session, you need to **attach** packages you want to use.

Functions and data are identified by their names (which cannot be duplicate within the same package).

Attaching a package to an R session, it means to make its function and data names available for you to call/use. I.e., you have expanded the _language_ (within the session)!
:::

## Your turn

::: callout-caution
## Your turn & Break

-   Connect to our [pad](https://bit.ly/ubep-rws-pad)(<https://bit.ly/ubep-rws-pad>)

-   Connect to the Day-1 project in RStudio cloud (<https://bit.ly/ubep-rws-rstudio>)

...and:
:::

1.  Run the code below and compare data frames and tibbles trying exploring its structure, subsetting it, or extracting some cloumn, rows, value(s). You can use `05-packages.R`. Which difference do you see? Write your opinions in the pad (we will discuss in a different lesson).

``` r
library(tibble)

db_tbl <- tibble(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)
db_tbl
```

2.  Find a package of your choice on Internet. Install it, attach it, explore its documentation. Find a function you like to use within the package; access its documentation, and provide an example code to use it.

```{r}
#| echo: false
countdown(
  minutes = 20,
  left = "45%",
  right = "5%",
  top = "55%",
  bottom = "15%",
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```

## Acknowledgment

To create the current lesson we explored, use, and adapt contents from the following resources:

-   [Carpentrie](https://carpentries.org/)'s [Programming with R](https://swcarpentry.github.io/r-novice-inflammation/) course material.
-   [Carpentrie](https://carpentries.org/)'s [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/) course material.
-   [Hadley Wickham](https://hadley.nz/)'s [Advanced R - (2e)](https://adv-r.hadley.nz)
-   [Hadley Wickham](https://hadley.nz/)'s [R for Data Science (2e)](https://r4ds.hadley.nz/)

The slides are made using [Posit](https://posit.co/)'s [Quarto](https://quarto.org/) open-source scientific and technical publishing system powered in R by [Yihui Xie](https://yihui.org/)'s [kintr](https://yihui.org/knitr/).

### Additionl Resources

-   The [Tidyverse](https://www.tidyverse.org/)

### License

```{=html}
 <p xmlns:cc="http://creativecommons.org/ns#" ><a rel="cc:attributionURL" href="https://github.com/UBESP-DCTV/2023-ecdc-rws">This work</a> by <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://github.com/CorradoLanera">Corrado Lanera, Ileana Baldi, and Dario Gregori</a> is licensed under <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></p> 
```
### References

